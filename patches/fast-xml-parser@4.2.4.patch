diff --git a/src/fxp.d.ts b/src/fxp.d.ts
index d622f27e33a2e02271c83326942a228c5df058fa..dff882417e668b53ca6b5eed3726f4e3d7549399 100644
--- a/src/fxp.d.ts
+++ b/src/fxp.d.ts
@@ -11,6 +11,8 @@ type X2jOptions = {
   trimValues: boolean;
   cdataPropName: false | string;
   commentPropName: false | string;
+  depth: number;
+  useOriginalTagNameOnJsonPath: boolean;
     /**
 Control how tag value should be parsed. Called only if tag value is not empty
 
@@ -30,7 +32,7 @@ Control how tag value should be parsed. Called only if tag value is not empty
   htmlEntities: boolean;
   ignoreDeclaration: boolean;
   ignorePiTags: boolean;
-  transformTagName: ((tagName: string) => string) | false;
+  transformTagName: ((tagName: string, jPath: string) => { newTagName: string, newExtraAttrs?: object }) | false;
   transformAttributeName: ((attributeName: string) => string) | false;
     /**
 Change the tag name when a different name is returned. Skip the tag from parsed result when false is returned. 
diff --git a/src/xmlparser/OrderedObjParser.js b/src/xmlparser/OrderedObjParser.js
index db11a8c06da37a2af73db75dfd36354dd4f698fc..a728a0061beb33582409fde68b9a889e4f732f7e 100644
--- a/src/xmlparser/OrderedObjParser.js
+++ b/src/xmlparser/OrderedObjParser.js
@@ -199,7 +199,8 @@ const parseXml = function(xmlData) {
         }
 
         if(this.options.transformTagName) {
-          tagName = this.options.transformTagName(tagName);
+          const { newTagName } = this.options.transformTagName(tagName, jPath.substr(0, jPath.lastIndexOf(".")));
+          tagName = newTagName;
         }
 
         if(currentNode){
@@ -284,8 +285,11 @@ const parseXml = function(xmlData) {
         let attrExpPresent = result.attrExpPresent;
         let closeIndex = result.closeIndex;
 
+        let extraAttrs = undefined;
         if (this.options.transformTagName) {
-          tagName = this.options.transformTagName(tagName);
+          const { newTagName, newExtraAttrs } = this.options.transformTagName(tagName, jPath);
+          tagName = newTagName;
+          extraAttrs = newExtraAttrs;
         }
         
         //save text as child node
@@ -303,9 +307,13 @@ const parseXml = function(xmlData) {
           jPath = jPath.substring(0, jPath.lastIndexOf("."));
         }
         if(tagName !== xmlObj.tagname){
-          jPath += jPath ? "." + tagName : tagName;
+          if (this.options.useOriginalTagNameOnJsonPath) {
+            jPath += jPath ? "." + result.tagName : result.tagName;
+          } else {
+            jPath += jPath ? "." + tagName : tagName;
+          }
         }
-        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
+        if (this.isItStopNode(this.options.stopNodes, jPath, tagName) || this.options.depth === jPath.split('.').length - 1) { //TODO: namespace
           let tagContent = "";
           //self-closing tag
           if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
@@ -346,13 +354,17 @@ const parseXml = function(xmlData) {
               tagExp = tagExp.substr(0, tagExp.length - 1);
             }
             
-            if(this.options.transformTagName) {
-              tagName = this.options.transformTagName(tagName);
+            let extraAttrs = undefined;
+            if (this.options.transformTagName) {
+              const { newTagName, newExtraAttrs } = this.options.transformTagName(result.tagName, jPath.substr(0, jPath.lastIndexOf(".")));
+              tagName = newTagName;
+              extraAttrs = newExtraAttrs;
             }
 
             const childNode = new xmlNode(tagName);
             if(tagName !== tagExp && attrExpPresent){
-              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
+              const attrMap = this.buildAttributesMap(tagExp, jPath, tagName);
+              childNode[":@"] = extraAttrs ? { ...extraAttrs, ...attrMap } : attrMap;
             }
             this.addChild(currentNode, childNode, jPath)
             jPath = jPath.substr(0, jPath.lastIndexOf("."));
@@ -363,7 +375,8 @@ const parseXml = function(xmlData) {
             this.tagsNodeStack.push(currentNode);
             
             if(tagName !== tagExp && attrExpPresent){
-              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
+              const attrMap = this.buildAttributesMap(tagExp, jPath, tagName);
+              childNode[":@"] = extraAttrs ? { ...extraAttrs, ...attrMap } : attrMap;
             }
             this.addChild(currentNode, childNode, jPath)
             currentNode = childNode;
diff --git a/src/xmlparser/node2json.js b/src/xmlparser/node2json.js
index 304557380dd8129d4b60f44b94223425b19fbe02..3750b5d31fd26009245999a81632d6217b62c840 100644
--- a/src/xmlparser/node2json.js
+++ b/src/xmlparser/node2json.js
@@ -43,7 +43,7 @@ function compress(arr, options, jPath){
         val = val[options.textNodeName];
       }else if(Object.keys(val).length === 0){
         if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
-        else val = "";
+        else val = options.tagValueProcessor?.(property, "", jPath + "." + property, false, true) ?? "";
       }
 
       if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {